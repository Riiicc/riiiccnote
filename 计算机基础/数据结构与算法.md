# 数据结构与算法

## 待办
- 快排的三种实现单边循环 双边循环 栈
- 桶排序
- 红黑树
- 跳表
- 


# 概述
程序 = 数据结构 + 算法  
数据结构是算法的基础  

## 线性结构
线性结构是最常用的数据结构，**数据元素之间存在一对一的线性关系**     
线性结构有两种不同的存储结构: 
- 顺序存储结构(数组)
  - 顺序存储的线性表称为顺序表,顺序表中的存储元素是连续的(地址连续)
- 链式存储结构(链表)
  - 链表中存储的元素不一定是连续的(地址),元素节点中存放数据元素以及相邻元素的地址信息
  - 链表可以充分利用磁盘碎片内存

线性结构常见的有: `数组`,`队列`,`链表`,`栈`


## 非线性结构
非线性结构包括:`二维数组`,`多维数组`,`广义表`,`树结构`,`图结构`


# 列表
列表是一种数据项构成的有限序列，即按照一定线性顺序，排列而成的数据项集合   
列表的概念是在集合上形成的，具有顺序，长度可变  


# 数组
数组是列表哦的实现方式之一，它具有列表的特征，主要区别就是**索引**   
数组会使用索引来表示每项数组在数组中的位置，大部分索引从0开始   
**数组中的元素在内存中是连续存储的，而且每个元素占用相同大小的内存**  

## 数组操作

计算机会在内存中申请一段连续的内存空间，并记下索引为`0`的内存地址
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/数组内存说明.jpg)

### 索引查找

当进行访问索引为`3`的元素时，会进行如下计算： 
- 找到该数组的索引`0`的内存地址`2008`
- 内存地址`2008+3 =2011`即找到目标索引的地址  
- 整个过程很快，因此可以将整个访问过程看所一个动作，时间复杂度`O(1)`

### 内容查找 
计算机只保存索引为`0` 的元素地址，所以查找数组是否包含某个元素时，只能从索引`0`开始   

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/数组内容查找.gif)

### 内容插入
插入到数组末尾，只需计算数组长度和即将插入元素地址，然后将该元素插入
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/数组元素插入.gif)

插入到数组其他位置，需要**依次腾出**位置，频繁插入效率低      
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/数组元素插入.gif)

### 删除
删除元素与插入元素类似，需要后面的元素依次填补   

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/元素删除.gif)

## 二维数组  
对于二维数组，内存同样连续，也只会记录第一行数组的索引位置 `[0][0]`   
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/二维数组内存说明.jpg)

## 稀疏数组
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/五子棋盘数组.png)

> 使用二维数组存盘功能很多值都是0,全部记录就会存储无意义数据,这时就需要**稀疏数组** 

当一个数组中大部分元素为0,或者同为一个值的数组时,可以使用稀疏数组来保存该数组   

稀疏数组处理方法
- 记录数组一共有几行几列,有多少个不同的值
- 把具有不同值的元素的行列及值记录在一个小规模的数组中,从而缩小程序规模

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/稀疏数组.png ':size=70%')

最后原来的`6 x 7 = 42`的二维数组 变为了`3 x 9 = 27`的数组

```java
public class SparseArray {
    public static void main(String[] args) {
        //创建一个原始的二维数组 11*11
        //0 表示没有棋子 1表示黑子 2表示白子

        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][4] = 1;
        for (int[] row : chessArr1) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
        //将二维数组转稀疏数组
        //1.遍历二维数组,得到非0数据个数
        int sum = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0) {
                    sum++;
                }
            }
        }
        System.out.println(sum);

        //2.创建对应的稀疏数组

        int sparseArr[][] = new int[sum + 1][3];
        //给稀疏数组赋值
        //存储原数组信息 行列 不同值的个数
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        //遍历 二维数组,将非0的值存放到sparseArr中
        int count = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0) {
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }

        System.out.println();
        System.out.println("得到的稀疏数组为");

        //打印稀疏数组
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        }

        //稀疏数组恢复为 二维数组
        //1.读取稀疏数组第一行,根据第一行数据,创建原始的二维数组
        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];

        //输出恢复后的二维数组
        for (int i = 1; i < sparseArr.length; i++) {
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        System.out.println();
        System.out.println("恢复的数组为");
        for (int[] row : chessArr2) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }



    }
}

```

```log
0	0	0	0	0	0	0	0	0	0	0	
0	0	1	0	0	0	0	0	0	0	0	
0	0	0	0	1	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
2

得到的稀疏数组为
11	11	2	
1	2	1	
2	4	1	

恢复的数组为
0	0	0	0	0	0	0	0	0	0	0	
0	0	1	0	0	0	0	0	0	0	0	
0	0	0	0	1	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	

```

# 链表  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/链表图.png)

- 链表是以节点的方式来存储
- 每个节点包含 data域,next域
- 链表各个节点不一定是连续存放的
- 链表分为带头节点的链表和不带头节点的链表


## 单链表 

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/链表结构.png)

链表的第一个结点和最后一个结点，分别称为链表的`首结点`和`尾结点`。**尾结点的特征是其 next 引用为空（null）**。链表中每个结点的 next 引用都相当于一个指针，指向另一个结点，借助这些 next 引用，我们可以从链表的首结点移动到尾结点。如此定义的结点就称为单链表（single linked list）   


单链表中的结点也具有一个线性次序，即如果结点 P 的 next 引用指向结点 S，则 P 就是 S 的直接前驱，S 是 P 的直接后续。**单链表的一个重要特性就是只能通过前驱结点找到后续结点，而无法从后续结点找到前驱结点**  


### 查找
单链表无法随机访问元素,若要获取第i个元素,必须从头节点开始遍历,访问元素平均花费`O(N)`,其中N是链表的长度

### 添加

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/单链表的添加.png ':size=60%')


除了单链表的首结点由于没有直接前驱结点，所以可以直接在首结点之前插入一个新的结点之外，在单链表中的其他任何位置插入一个新结点时，**都只能是在已知某个特定结点引用的基础上在其后面插入一个新结点**。并且在已知单链表中某个结点引用的基础上，完成结点的插入操作需要的时间是`O(1)`。

### 修改
通过遍历找到节点,进行修改

### 删除节点 
在单链表中删除一个结点时，除首结点外都必须知道该结点的直接前驱结点的引用。并且在已知单链表中某个结点引用的基础上，完成其后续结点的删除操作需要的时间是 `O(1)`    
被删除(无引用)的节点会在垃圾回收时被删除   

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/单链表的删除.png ':size=60%')


### 题目
```java
class HeroNode {
    public int no;
    public String name;
    public String nickname;
    public HeroNode next;
}
```

1. 获取单链表的节点个数(若是带头节点的链表,不统计头节点)

```java
public static int getLength(HeroNode head) {
        if (head.next == null) {
            return 0;
        }
        int length = 0;
        //直接掠过头节点
        HeroNode cur = head.next;
        while (cur != null) {
            length++;
            cur = cur.next;
        }
        return length;
    }
```

2. 单链表的倒数第k个节点

```java

    //查找第k个节点
    //方法接收 head(头) 节点 和 index (k)
    //先把链表进行遍历,进行统计节点个数
    //得到length后 再次遍历链表 到 length-index个位置
    public static HeroNode getKNode(HeroNode node,int index){
        if(node.next ==null){
            return null;
        }
        //第一次遍历获取长度
        int length = 0;
        //直接掠过头节点
        HeroNode cur = node.next;
        while (cur != null) {
            length++;
            cur = cur.next;
        }
        //第二次遍历 找第 length-index个
        if (index<=0||index>length){
            return null;
        }

        HeroNode cur1 = node.next;
        for (int i = 0; i < length - index; i++) {
            cur1 = cur1.next;
        }
        return cur1;
    }

```

3. 单链表的反转    
思路    
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/链表题3.png)

```java
public static void reverseList(HeroNode head){
        //空和一直有一个节点无需操作
        if(head.next ==null|| head.next.next == null){
            return ;
        }
        HeroNode temp = head.next;
        HeroNode next = null;
        HeroNode newHead = new HeroNode(0, "", "");
        while (temp!=null){
               //保存当前节点的下一个节点
               next = temp.next;
               temp.next = newHead.next;
               newHead.next = temp;
               temp = next;
        }
        head.next = newHead.next;

    }
```

4. 从尾到头打印单链表  

- 先反转再遍历,不建议,改变了原结构
- 利用栈,将各节点压入栈中,利用栈的先进后出特点,实现逆序打印效果 



```java

    /**
     * 反向打印链表 ,不改变链表结构顺序
     * @param head 头节点
     */
    public static void reversePrint(HeroNode head){
        if (head.next==null){
            return;
        }
        //创建栈
        Stack<HeroNode> stack = new Stack<>();
        HeroNode cur = head.next;

        //将链表所有节点压栈
        while (cur!=null){
            stack.push(cur);
            cur = cur.next;//后移
        }
        while (stack.size()>0){
            System.out.println(stack.pop());
        }
    }

```

## 双向链表 

> 单链表的缺点: 单链表中只能通过一个结点的引用访问其后续结点，而无法直接访问其前驱结点，要在单链表中找到某个结点的前驱结点，必须从链表的首结点出发依次向后寻找，但是需要`O(n)`时间   

单链表结点结构中新增加一个域，该域用于指向结点的直接前驱结点,这就是双链表  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/双向链表.png)

双向链表是通过上述定义的结点使用 pre 以及 next 域依次串联在一起而形成的。一个双向链表的结构如下图所示

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/双向链表1.png)



### 查找
在双向链表中进行查找与在单链表中类似，只不过在双向链表中查找操作可以从链表的首结点开始，也可以从尾结点开始，但是需要的时间和在单链表中一样  

### 添加
单链表的插入操作，**除了首结点之外必须在某个已知结点后面进行**，而在双向链表中插入操作在一个已知的结点之前或之后都可以进行，如下表示在结点 11 之前 插入 9。

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/double-linkedlist-add.png)

### 删除
单链表的删除操作，除了首结点之外必须在知道待删结点的前驱结点的基础上才能进行，而在双向链表中在已知某个结点引用的前提下，可以完成该结点自身的删除，注意若删除最后节点不需要迁移next指针

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/double-linkedlist-del.png)



## 单向环形链表(约瑟夫环)

> N个人围成一圈，第一个人从1开始报数，数到M的人出列，下一个人接着从1开始报，数到M出列，如此反复，最后剩下一个   
> 若有三个人，数到2出列，那么 ABC三人，A开始数1，B出列，C数1，A出列，最终剩下C  


### 构建环形链表
1. 创建第一个节点,让first 节点指向该节点,形成环形
2. 后面每次创建一个新节点,就把该节点加入到已有的环形链表中即可   
3. 遍历环形链表:让一个辅助指针`cur`指向first,然后进行遍历,当`cur.next==frist`时算结束


### 代码实现
首先构建基本的单向环形链表 

```java
//节点类
class Boy{
    private int no;
    private Boy next;
    public Boy(int no) {
        this.no = no;
    }
    public int getNo() {
        return no;
    }
    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }
    public void setNext(Boy next) {
        this.next = next;
    }
}
```

```java
//环形单向链表
class CircleSingleLinkedList{
    //创建一个first节点
    private Boy first = new Boy(-1);
    //添加节点 num个
    public void addBoy(int num){
        if (num<1){
            System.out.println("num数值不正确");
            return;
        }
        //辅助变量 指针
        Boy cur = null;
        for (int i = 1; i <= num; i++) {
            //根据编号创建节点
            Boy boy = new Boy(i);
            //第一个特殊处理成环形
            if (i ==1){
                first = boy;
                first.setNext(first);//构成环
                cur = first;
            }else {
                cur.setNext(boy);
                boy.setNext(first);
                cur = boy;
            }
        }
    }
    //遍历当前环形链表
    public void showBoy(){
        if (first==null){
            System.out.println("链表为空");
            return;
        }
        Boy cur = first;
        while (true){
            System.out.println("当前编号"+cur.getNo());
            if (cur.getNext() == first){
                //遍历完毕了
                break;
            }
            //后移
            cur = cur.getNext();
        }
    }
}
```

构建思路  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/约瑟夫环代码说明图.png)


```java

    /**
     * @param startNo  从第几个开始数
     * @param countNum 数几下
     * @param nums     最初有多少人
     */
    public void countBoy(int startNo, int countNum, int nums) {
        if (first == null || startNo < 1 || startNo > nums) {
            System.out.println("参数有误");
            return;
        }
        //辅助指针 指向最后一个
        Boy helper = first;
        while (true) {
            if (helper.getNext() == first) {
                break;
            }
            helper = helper.getNext();
        }
        //从startno开始报数,那么就先将指针定位到startno
        for (int j = 0; j < startNo - 1; j++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        //循环到圈中只有一个节点 即 helper == first
        while (true) {
            if (helper == first) {
                break;
            }
            for (int j = 0; j < countNum - 1; j++) {
                first = first.getNext();
                helper = helper.getNext();
            }

            System.out.println(first.getNo() + "出圈");
            //移动
            first = first.getNext();
            helper.setNext(first);
        }
        System.out.println("剩下的编号是" + first.getNo());
    }
```

```java
//测试
 public static void main(String[] args) {
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);
        circleSingleLinkedList.showBoy();

        circleSingleLinkedList.countBoy(1, 2, 5);
    }
// 2出圈
// 4出圈
// 1出圈
// 5出圈
// 剩下的编号是3
```



# 队列  
- 队列是一个**有序**列表,可以用`数组`或者是`链表`来实现
- 遵循先入先出的原则,即:**先存入队列的数据,要先取出,后存入的要后取出**    
- 先入先出 `First In First Out` **FIFO**

## 数组实现队列
队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 `maxSize` 是该队列的最大容量。    
因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 `front` 及 `rear`分别记录队列前后端的下标，`front` 会随着数据输出而改变，而 `rear`则是随着数据输入而改变  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/队列列表实现说明图.png)

代码实现

```java
package com.ric.queue;

import java.util.Scanner;

/**
 * 类描述
 */
public class ArrayQueueDemo {
    public static void main(String[] args) {
        ArrayQueue arrayQueue = new ArrayQueue(3);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);

        boolean loop = true;
        while (loop) {
            System.out.println("s-show 显示队列");
            System.out.println("e-exit 退出程序");
            System.out.println("a-add 添加数据到队列");
            System.out.println("g-get 从队列取出数据");
            System.out.println("h-head 查看队列头的数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    arrayQueue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int i = scanner.nextInt();
                    arrayQueue.addQueue(i);
                    break;
                case 'g':
                    try {
                        int queue = arrayQueue.getQueue();
                        System.out.println("取出的数据是" + queue);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }

                    break;
                case 'h':
                    try {
                        int i1 = arrayQueue.showHead();
                        System.out.println("取出的头是" + i1);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
    }
}

class ArrayQueue {
    //最大容量
    private int maxSize;
    //队列头
    private int front;
    //队列尾
    private int rear;
    //模拟队列
    private int[] arr;

    public ArrayQueue(int arrmaxSize) {
        maxSize = arrmaxSize;
        arr = new int[arrmaxSize];
        front = -1;
        rear = -1;
    }

    public boolean isFull() {
        return rear == maxSize - 1;
    }

    public boolean isEmpty() {
        return rear == front;
    }

    public void addQueue(int n) {
        if (isFull()) {
            System.out.println("队列满不能加入数据");
        } else {
            rear++;
            arr[rear] = n;
        }
    }

    public int getQueue() {
        if (isEmpty()) {
            System.out.println("队列空,不能取数据");
            throw new RuntimeException("队列空,不能取数据");
        } else {
            front++;
            return arr[front];

        }
    }

    public void showQueue() {
        if (isEmpty()) {
            System.out.println("队列空,无数据");
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr - %d = %d\n", i, arr[i]);

        }
    }

    public int showHead() {
        if (isEmpty()) {
            System.out.println("队列空,无数据");
            throw new RuntimeException("队列空,无数据");
        } else {
            return arr[front + 1];
        }
    }
}
```

> 当前数组队列,只能使用一次,无法复用  



## 数组实现环形队列

对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。  
通过**取模**的方式来实现即可   

- 通过 `(rear + 1 )% maxSize = front` 来判断队列是否已满
- `(rear + maxSize - front)% maxSize` 获取队列中的有效数据个数

```java
package com.ric.queue;

import java.util.Scanner;

/**
 * 环形队列模拟
 */
public class ArrayQueueCircleDemo {
    public static void main(String[] args) {
        ArrayQueueCircle arrayQueue = new ArrayQueueCircle(4);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);

        boolean loop = true;
        while (loop) {
            System.out.println("s-show 显示队列");
            System.out.println("e-exit 退出程序");
            System.out.println("a-add 添加数据到队列");
            System.out.println("g-get 从队列取出数据");
            System.out.println("h-head 查看队列头的数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    arrayQueue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int i = scanner.nextInt();
                    arrayQueue.addQueue(i);
                    break;
                case 'g':
                    try {
                        int queue = arrayQueue.getQueue();
                        System.out.println("取出的数据是" + queue);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
//                        e.printStackTrace();
                    }

                    break;
                case 'h':
                    try {
                        int i1 = arrayQueue.showHead();
                        System.out.println("取出的头是" + i1);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
//                        e.printStackTrace();
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }


    }
}


class ArrayQueueCircle {
    //最大容量
    private int maxSize;
    //队列头
    private int front;
    //队列尾
    private int rear;
    //模拟队列
    private int[] arr;

    public ArrayQueueCircle(int arrmaxSize) {
        maxSize = arrmaxSize;
        arr = new int[arrmaxSize];
        front = 0;
        rear = 0;
    }

    public boolean isFull() {

        return (rear+1)%maxSize == front;
    }

    public boolean isEmpty() {
        return rear == front;
    }

    public void addQueue(int n) {
        if (isFull()) {
            System.out.println("队列满不能加入数据");
        } else {
            arr[rear] = n;
            //将rear 后移 取模
            rear = (rear+1) % maxSize;
        }
    }

    public int getQueue() {
        if (isEmpty()) {
            System.out.println("队列空,不能取数据");
            throw new RuntimeException("队列空,不能取数据");
        } else {
            //将front 对应的值保存到一个临时变量
            //将front 后移,取模
            //将临时保存的变量返回
            int value = arr[front];
            front = (front+1)%maxSize;
            return value;

        }
    }

    public void showQueue() {
        if (isEmpty()) {
            System.out.println("队列空,无数据");
        }
        //从front 开始遍历
        for (int i = front; i < front +getSize(); i++) {
            int i1 = i % maxSize;
            System.out.printf("arr - %d = %d\n", i1, arr[i1]);

        }
    }

    //当前队列有效数据的个数
    int getSize(){

        return  (rear = maxSize - front) % maxSize;
    }

    public int showHead() {
        if (isEmpty()) {
            System.out.println("队列空,无数据");
            throw new RuntimeException("队列空,无数据");
        } else {
            return arr[front + 1];
        }
    }
}
```

## 链式队列
队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出，简称为链队列   

根据单链表的特点，链表尾部作为队尾，队首指针指向队首元素前一个节点，即链表头节点，队尾指针指向队尾元素所在节点    

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/链式队列.jpg)  

队列为空时，队首指针与队尾指针均指向空的头节点   

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/链式队列空队列.jpg)

# 栈 
栈（stack）是限定仅在表尾一端进行插入或删除操作的特殊线性表。又称为堆栈。  
对于栈来说, 允许进行插入或删除操作的一端(变化的一端)称为栈顶（top），而另一端(固定的一端)称为栈底（bottom）。不含元素栈称为空栈，向栈中插入一个新元素称为入栈或压栈， 从栈中删除一个元素称为出栈或退栈   

- 栈中数据是按照"后进先出（LIFO, Last In First Out）"方式进出栈的。
- 向栈中添加/删除数据时，**只能**从栈顶进行操作

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/栈说明.jpg)

栈的基本操作除了进栈` push()`，出栈 `pop()` 之外，还有判空 `isEmpty()`、取栈顶元素 `peek()` 等操作

应用: 
- 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 	
- 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
- 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
- 二叉树的遍历。
- 图形的深度优先(depth一first)搜索法

我们可以使用数组或者链表来模拟栈  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/数组模拟栈.png)

## 前缀、中缀、后缀 表达式

前缀表达式(波兰表达式): 前缀表达式的运算符位于操作数之前   
例: `(3+4)×5-6` 对应的前缀表达式就是 `- × + 3 4 5 6`  

> **前缀表达式的计算机求值**:`从右至左`扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果  

中缀表达式: 就是常见的运算表达式,如:(3+4)×5-6   
中缀表达式对于计算机来说是不好操作的的,一般会将中缀表达式转为其他表达式来操作  

后缀表达式(逆波兰表达式):运算符位于操作数之后  
例:`(3+4)×5-6` 对应的后缀表达式就是 `3 4 + 5 × 6 -`  

正常表达式 | 逆波兰表达式 |
---------|----------|
 a+b | a b + |
 a+(b-c)| a b c - + | 

> 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈   

## 中缀表达式转换为后缀表达式
思路分析：

P39 直接跳到 P43




# 递归
递归就是方法自己调用自己,每次调用时传入不同的变量  

```java

//简易递归方法
 public static void test(int n) {
    if (n > 2) {
        test(n - 1);
    }
    System.out.println("n=" + n);
}

//阶乘
public static int jiecheng(int n) {
    if (n == 1) {
        return 1;
    } else {
        return jiecheng(n - 1) * n;
    }
}
```

## 迷宫回溯问题

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/迷宫回溯.png)

```java
public class MiGong {
    public static void main(String[] args) {
        int[][] map = new int[8][7];

        //使用1 表示墙
        //上下全部置为1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }

        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }

        map[3][1] = 1;
        map[3][2] = 1;

        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + "     ");
            }
            System.out.println();
        }
        System.out.println();

        setWay(map, 1, 1);

        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + "     ");
            }
            System.out.println();
        }

    }

    /**
     * @param map 地图
     * @param i   j 表示从哪个位置开始找
     *            从1，1 出发，找到6，5 即为结束
     *            [i][j] 为0表示没走过，1表示墙，2表示走过（可以走），3表示走过 （走不通）
     *            策略 ：先向下——右—上——左 走不通再回溯
     */
    public static boolean setWay(int[][] map, int i, int j) {
        //已找到
        if (map[6][5] == 2) {
            return true;
        } else {
            if (map[i][j] == 0) {
                map[i][j] = 2;
                if (setWay(map, i + 1, j)) {
                    //向下走
                    System.out.println("向下走");
                    return true;
                } else if (setWay(map, i, j + 1)) {
                    //向右走
                    System.out.println("向右走");
                    return true;
                } else if (setWay(map, i - 1, j)) {
                    //向上走
                    System.out.println("向上走");
                    return true;
                } else if (setWay(map, i, j - 1)) {
                    //向左走
                    System.out.println("向左走");
                    return true;
                } else {
                    //说明该点 i,j是死路
                    map[i][j] = 3;
                    return false;
                }
            } else {
                return false;
            }
        }
    }
}
```

> 最短路径问题，通过穷举找到最短路径   


## 八皇后问题(回溯算法)

> 在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/八皇后问题.png)

- 第一个皇后先放第一行第一列
- 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
- 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
- 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.
- 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤


> 理论上应该采用二维数组解决，实际上可以采用一维数组，每行只能有一个皇后，所以将下标看作行，值看作列，`arr[i] = val`表示放在第`i+1`行(第`i+1`个皇后)的第`val+1`列


```java
public class Queen8 {
    //皇后总数
    int max = 8;
    //定义数组，保存解法结果
    int[] arr = new int[max];
    static int count = 0;

    public static void main(String[] args) {

        Queen8 queen8 = new Queen8();
        queen8.check(0);
        System.out.println(count);
    }
    /**
     * 判断 第n个皇后和前面已经拜访的皇后是否冲突
     *
     * @param n
     * @return
     */
    private boolean judge(int n) {
        for (int i = 0; i < n; i++) {
            //判断第n个皇后是否跟前面的皇后在同一列
            if (arr[i] == arr[n] ||
                    //判断第n个皇后是否和第i个皇后在同一斜线 循环即判断之前已经放置的皇后
                    Math.abs(n - i) == Math.abs(arr[n] - arr[i])) {
                return false;
            }
        }
        return true;
    }

    private void check(int n){
        if (n ==max){ //n==8 n是index  n为8的时候 是第九次放置，8个皇后已经放好了
            print();
            return;
        }
        //依次放入皇后 并判断是否冲突
        for (int i = 0; i < max; i++) {
            //先把当前皇后 放到该行第一（0）列
            arr[n] = i;
            //判断放置第n个皇后的i列时 是否冲突
            if (judge(n)){
                //不冲突，继续放 n+1个
                check(n+1);

            }
        }
    }
    private void print() {
        count++;
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "  ");
        }
        System.out.println();
    }
}
```


# 排序算法
排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程

## 分类 
- 内部排序，数据全部加载进内存排序
  - 插入排序：直接插入排序，希尔排序
  - 选择排序：简单选择排序，堆排序
  - 交换排序：冒泡排序，快速排序
  - 归并排序
  - 基数排序
- 外部排序，数据量过大，借助外部存储  

## 稳定性界定
> 假设一个数组`array`中有两个值相同`array[i] == array[j]` 其中`i!=j`,且排序前`array[i]`领先于`array[j]` 即 `i < j`,若排序后`array[i]`仍领先于`array[j]`则称所用的排序方法是**稳定**的，反之，若可能使得排序后的序列中 `array[j]`领先于`array[i] 则称所用的排序方法是**不稳定**的

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/排序稳定性.png)

## 算法的时间复杂度

### 时间频度
一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为`T(n)`

```java
//T(n) = n+1
 int n=100; int sum = 0;
 for (int i = 0; i < n; i++) {
    sum++; //计算100次
}

//计算两次 T(n) = 1
int i =0;int n=100;int sum = 0;
sum= (1+n)*n/2;
```

###  时间复杂度

>  一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用`T(n)`表示，若有某个辅助函数`f(n)`，使得当n趋近于无穷大时，`T(n)/f(n)` 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 `T(n)=O(f(n))`，称`O(f(n))` 为算法的**渐进时间复杂度**，简称**时间复杂度**   
> 这种表示方法我们称为「` 大O符号表示法` 」，又称为渐进符号，是用于描述函数渐进行为的数学符号

`T(n)`不同，但时间复杂度可能相同。 如：`T(n)=n²+7n+6` 与 `T(n)=3n²+2n+2` 它们的`T(n)` 不同，但时间复杂度相同，都为`O(n²)`  

计算方法：
- 有n时忽略常数 
- 有高次方忽略低次方
- 去除最高阶项的系数 


### 常见的时间复杂度
下面是常见的时间复杂度，由小到大排序

- 常数阶`O(1)`
- 对数阶`O(log n)`
- 线性阶`O(n)`
- 线性对数阶`O(n log n)`
- 平方阶`O(n²)`
- 立方阶`O(n³)`
- k次方阶`O(n^k)`
- 指数阶`O(2^n)`

#### 常数阶 
`O(1)`表示该算法的执行时间总是为一个常量，不论输入的数据集是大是小，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是`O(1)`

```java
int i = 1;
int j = 2;
int k = i + j;
```

上述代码的消耗，并不随某个变量的增长而增长，无论这个代码有多长，它的时间复杂度都是`O(1)`

#### 对数阶  

```java
int i = 1;
while(i<n){
    i = i * 2;
}
```

while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了，直到i不小于n退出。我们试着求解一下，假设循环次数为x，也就是说 2 的 x 次方等于 n，则由`2^x=n`得出`x=log₂n`。因此这个代码的时间复杂度为`O(logn )`

#### 线性阶
```java
for (int i = 0; i < n; i++) {
   j = i;
   j++;
}
```

for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用`O(n)`来表示它的时间复杂度

#### 线性对数阶
线性对数阶，可以理解为线性阶*对数阶,代码简单表现为 for循环嵌套while循环

```java
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

线性对数阶`O(nlogN)`其实非常容易理解，将时间复杂度为`O(logn)`的代码循环N遍的话，那么它的时间复杂度就是 `n * O(logN)`，也就是了`O(nlogN)`


#### 平方阶/立方阶、k次方阶
X次方阶 即for循环嵌套X次  

```java
for(x=1; i<=n; x++){
   for(i=1; i<=n; i++){
       j = i;
       j++;
    }
}
```

#### 指数阶
表示一个算法的性能会随着输入数据的每次增加而增大两倍，典型的方法就是裴波那契数列的递归计算实现

```java
int Fibonacci(int number){
    if (number <= 1) return number;

    return Fibonacci(number - 2) + Fibonacci(number - 1);
}
```

### 大O曲线

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/大O时间复杂度曲线.jpg)

### 平均/最差 时间复杂度

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/排序时间复杂度大全.jpg ':size=70%')

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/数据结构时间复杂度大全.jpg ':size=70%')

## 空间复杂度
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，通过计算一个算法所需的存储空间来实现    
公式记作：`S(n) = O(f(n))` 其中 n 为问题的规模，f(n)为语句关于n所占存储空间的函数   
空间复杂度常用的有`O(1)` `O(n)` `O(n²)`

?> 通常情况下我们都使用`时间复杂度`来指运行时间的需求,使用`空间复杂度`指空间需求,当不限定用`复杂度`时,通常指`时间复杂度`

## 冒泡排序 Bubble Sort
冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部

两个冒泡排序的动画  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/Bubble-sort-example-300px.gif) 

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/Sorting_bubblesort_anim.gif)

- 总共进行数组大小-1次循环(剩下的肯定是最小的)
- 每次循环交换的位置在逐渐减少
- **优化**：如果在某次循环中没有发生一次交换，可以提前结束冒泡排序 
- 冒泡排序的时间复杂度是平方阶`O(n²)`

```java

public class BubbleSort {
    //基础版  
    public static void main(String[] args) {
        int arr[] = {3,9,-1,10,-2};
        int temp = 0;
        for (int j = 0; j < arr.length - 1; j++) {
            for (int i = 0; i < arr.length-1-j; i++) {
                if (arr[i]>arr[i+1]){
                    temp = arr[i];
                    arr[i] = arr[i+1];
                    arr[i+1] = temp;
                }
            }
            System.out.println("第"+j+"次结果："+Arrays.toString(arr));
        }
    }

    //优化版
    public static void main(String[] args) {
        int arr[] = {3,9,-1,10,-2};
        int temp = 0;
        boolean flag = false;
        for (int j = 0; j < arr.length - 1; j++) {
            for (int i = 0; i < arr.length-1-j; i++) {
                if (arr[i]>arr[i+1]){
                    flag = true;
                    temp = arr[i];
                    arr[i] = arr[i+1];
                    arr[i+1] = temp;
                }
            }
            System.out.println("第"+j+"次结果："+Arrays.toString(arr));
            if (!flag){
                break;
            }else {
                flag = false;
            }
        }
    }
}
```

## 选择排序 Selection Sort
选择排序(select sorting)也是一种简单的排序方法。它的基本思想是：第一次从`arr[0]~arr[n-1]`中选取最小值，与`arr[0]`交换，第二次从`arr[1]~arr[n-1]`中选取最小值，与`arr[1]`交换，第三次从`arr[2]~arr[n-1]`中选取最小值，与`arr[2]`交换，…，第i次从`arr[i-1]~arr[n-1]`中选取最小值，与`arr[i-1]`交换，…, 第n-1次从`arr[n-2]~arr[n-1]`中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列    

选择排序的时间复杂度为 `O(n²)`  

选择排序动画：  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/SelectionSort_Avg_case.gif)

```java

 //第一轮
        arr = new int[]{1,32,119,101};
        //假定最小值是第一个
        int minIndex = 0;
        int min = arr[0];
        for (int j = 0+1; j < arr.length; j++) {
            //使用第一个和第二个进行比较，若第二个小于第一个，那么就将第二个值赋给min
            if(min> arr[j]){
                min = arr[j];
                minIndex = j;
            }
        }
        //将arr 0 放在原来最小值的位置上
        arr[minIndex] = arr[0];
        //将整个数组的最小值放在arr[0上
        arr[0] = min;
        //上述即一次循环的结果

```

```java
//最终版
 public static  void selectSort(int[] arr){
        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;
            int min = arr[i];
            for (int j = i+1; j < arr.length; j++) {
                if(min> arr[j]){
                    min = arr[j];
                    minIndex = j;
                }
            }
            if(minIndex!=0){
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
            System.out.println("第"+i+1+ Arrays.toString(arr));
        }
    }
```

## 插入排序 Insertion Sort

把n个待排序的元素看成为一个`有序表`和一个`无序表`，开始时`有序表`中只包含一个元素，`无序表`中包含有`n-1`个元素，排序过程中每次从`无序表`中取出第一个元素，把它的排序码依次与`有序表`元素的排序码进行比较，将它插入到`有序表`中的适当位置，使之成为新的`有序表`

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/Insertion_Sorting.gif)


```java

    public static void insertSort(int[] arr){
        //第一轮
        //定义待插入的数
        int insertValue = arr[1];
        int insertIndex = 0;//1-1

        //给insertvalue找到插入位置
        //insertindex >=0保证 insertval找插入位置不越界
        //insertvalue < arr[insertIndex] 待插入的数，还没找到插入位置
        while (insertIndex>=0 && insertValue<arr[insertIndex]){
            arr[insertIndex+1] = arr[insertIndex];
            insertIndex--;
        }
        //退出循环说明插入的位置找到，insertIndex+1
        arr[insertIndex+1] = insertValue;
        System.out.println(Arrays.toString(arr));

        //第二次
        insertValue = arr[2];
        insertIndex = 1;//2-1

        while (insertIndex>=0 && insertValue<arr[insertIndex]){
            arr[insertIndex+1] = arr[insertIndex];
            insertIndex--;
        }
        //退出循环说明插入的位置找到，insertIndex+1
        arr[insertIndex+1] = insertValue;
        System.out.println(Arrays.toString(arr));

    }
```

```java

   
    public static void insertSortX(int[] arr){
        //定义待插入的数
        int insertValue = 0;
        int insertIndex= 0;
        for (int i = 1; i < arr.length; i++) {
            insertValue = arr[i];
            insertIndex = i-1;//1-1
            while (insertIndex>=0 && insertValue<arr[insertIndex]){
                arr[insertIndex+1] = arr[insertIndex];
                insertIndex--;
            }
            //退出循环说明插入的位置找到，insertIndex+1
            if(insertIndex+1 !=i){
                arr[insertIndex+1] = insertValue;
                System.out.println(Arrays.toString(arr));
            }
        }
    }
```

## 希尔排序 Shell Sort
希尔排序这个名字，来源于它的发明者希尔，也称作`缩小增量排序`，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法     
希尔排序是把记录按下标的一定增量分组，对每组使用直接`插入排序`算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止  

排序过程： 
1. 假设我们有原始数组如下   
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/希尔排序原始数组.png)

2. 设置初始步长进行进行分割 `gap=length/2 = 5` 以5为步长进行匹配   
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/希尔排序原始数组1.png)

3. 我们可以看到，`8,3` `9,5` `1,4` `7,6` `2,0` 分为五组，对着五组进行插入排序，小的在前大的在后，最后`3,5,6,0`被调换到前面，得到新数组`3,5,1,6,0,8,9,4,7,2`
4. 然后**缩小增量**，`gap = 5/2 = 2`,分组如图   
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/希尔排序原始数组2.png)

5. 分割为两组`3,1,0,9,7` `5,6,8,4,2`，对着两组分别进行插入排序得到数组 `0,2,1,4,3,5,7,6,9,8`    
6. 再次缩小增量 `gap = 2/2 = 1` 此时增量变为1，即所有原始数组为一组，进行插入排序，最终得到`0,1,2,3,4,5,6,7,8,9`  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/希尔排序原始数组3.png)

```java

    public static void shellSort(int[] arr) {
        //第一轮排序
        //将十个数据分成五组
        int temp = 0;
        for (int i = 5; i < arr.length; i++) {
            //遍历各组中所有元素，共5组，每组两个元素
            for (int j = i - 5; j >= 0; j -= 5) {
                if(arr[j]>arr[j+5]){
                    temp = arr[j];
                    arr[j] = arr[j+5];
                    arr[j+5] = temp;
                }
            }
        }
    }
```

```java
    //最终版 交换法 
    public static void shellSortX(int[] arr) {
        int temp = 0;
        for (int gap = 0; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                for (int j = i - gap; j >= 0; j -= gap) {
                    if (arr[j] > arr[j + gap]) {
                        temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }
                }
            }
        }
    }
    //移动法
    public static void shellSortX2(int[] arr) {
        int temp = 0;
        for (int gap = 0; gap > 0; gap /= 2) {
            //对第 gap 个元素开始，逐个对其所在的组进行直接插入排序
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                temp  = arr[j];
                //分组完成的后面的元素小于前面的元素
                if (arr[j]<arr[j-gap]){
                    while (j-gap >=0 && temp < arr[j-gap]){
                        arr[j]= arr[j-gap];
                        j -= gap;
                    }
                    //退出while循环后找到了插入位置
                    arr[j] = temp;
                }
            }
        }
    }
```

## 快速排序  Quick Sort
`快速排序`是对`冒泡排序`的一种改进，快速排序的核心思想也是`分治法`，分而治之。它的实现方式是每次从序列中选出一个`基准值`，其他数依次和基准值做比较，比基准值大的放右边，比基准值小的放左边，然后再对左边和右边的两组数分别选出一个基准值，进行同样的比较移动，重复步骤，直到最后都变成单个元素，整个数组就成了有序的序列

?> `分治法`把任意大小问题尽可能地等分成两个子问题的递归算法

快排还分单边循环法 和双边循环法，以及非递归(使用栈保存临时数据)方法，演示代码为双边循环   

```java

    /**
     * @param left 起始index
     * @param right 结束index
     */
    public static void quickSort(int[] arr, int left, int right) {
        int l = left;
        int r = right;
        //取中间的索引
        int pivot = arr[(l + r) / 2];
        int temp = 0;
        //让比中间值 小的放到其左边 ，大的放到右边
        while (l < r) {
            //在左边一直找，找到大于pivot的值退出 此时arr[l] 就是一个待交换的值
            while (arr[l] < pivot) {
                l++;
            }
            //在左边一直找，找到小于于pivot的值退出 此时arr[r] 就是一个待交换的值
            while (arr[r] > pivot) {
                r--;
            }
            //此时左右已经交汇 全找完了
            //左边全是小于的 右边全是大于的
            if (l >= r) {
                break;
            }
            //交换两个值
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            //若右边找到一个等于 pivot 的值就将左边继续向右移动
            if (arr[r] == pivot) {
                l++;
            }
            if (arr[l] == pivot) {
                r--;
            }
        }
        //若l==r 必须将l++ 或者r--
        if (l == r) {
            l++;
            r--;
        }
        if (left < r) {
            quickSort(arr, left, r);
        }
        if (right > l) {
            quickSort(arr, l, right);
        }
        System.out.println(Arrays.toString(arr));
    }
```

## 归并排序 Marge Sort  
归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用   

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/MergeSort_Avg_case.gif)

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/归并分治.png ':size=70%')

```java

    /**
     * 分解方法
     */
    public static void mergeSort(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = (left + right) / 2;
            //向左递归进行分解
            mergeSort(arr,left,mid,temp);
            //向右递归分解
            mergeSort(arr,mid+1,right,temp);
            //合并
            merge(arr,left,mid,right,temp);
        }
    }

    /**
     * @param left  左边有序序列的初始索引
     * @param mid   中间索引
     * @param right 右边索引
     * @param temp  用作中转的数组
     */
    public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;//初始化 i 左边有序序列的指针 初始索引
        int j = mid + 1;//右边有序序列的初始化索引
        int t = 0; //指向temp数组的当前索引
        // 一
        //先把左右两边的有序数据,按规则，填充到 temp 数组
        //直到左右两边的有序序列，有一边处理完毕为止
        while (i <= mid && j <= right) {//左边的没到中间，右边的没到最后
            if (arr[i] <= arr[j]) {
                //左边的小于右边的，就把左边的放入temp,然后移动左边的指针
                temp[t] = arr[i];
                t++;
                i++;
            } else {
                //右边的小
                temp[t] = arr[j];
                t++;
                j++;

            }
        }
        // 二
        // 把有剩余数据的一边的数据，依次全部填充到 temp
        while (i <= mid) {
            //左边序列还有剩余，全部填充到temp
            temp[t] = arr[i];
            t++;
            i++;
        }

        while (j <= right) {
            //右边序列还有剩余，全部填充到temp
            temp[t] = arr[j];
            t++;
            j++;
        }
        // 三
        //将 temp数组数据拷贝到原数组
        t = 0;
        int tempLeft = left;
        while (tempLeft <= right) {
            arr[tempLeft] = temp[t];
            t++;
            tempLeft++;
        }
    }

```

## 基数排序 Radix Sort
1. 基数排序 `Radix sort`属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用   
2. 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法    
3. 基数排序是`桶排序`的扩展

实现过程： 
对位数不足的前面补零方便观察  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/基数排序基本实现.jpg)

```java
    //单次处理理解    
    public static void radixSort(int[] arr) {
        //int[] arr = {53,3,542,748,14,214};
        //第一轮针对每个元素的个位进行排序处理
        //定义一个二维数组，表示10个桶，每个桶就是一个一维数组
        //为了放置数据溢出，每个桶的大小都是 arr.length
        int[][] bucket = new int[10][arr.length];
        //记录每个桶中存放了多少有效数据
        //bucketElementCounts[0 第一个桶的数据个数
        int[] bucketElementCounts = new int[10];

        for (int j = 0; j < arr.length; j++) {
            int digitOfElement = arr[j] % 10;//取个位
            //放入对应桶
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        // 按照桶的顺序，一维数组的下标一次取出数据，放入到原来的数组
        int index = 0;
        for (int k = 0; k < bucketElementCounts.length; k++) {
            if (bucketElementCounts[k] != 0) {
                //有数据的
                //遍历这个数组
                for (int i = 0; i < bucketElementCounts[k]; i++) {
                    arr[index++] = bucket[k][i];
                }
            }
            //清空
            bucketElementCounts[k] = 0;
        }
        System.out.println(Arrays.toString(arr));
        //[542, 53, 3, 14, 214, 748]

        //第二次排序根据十位的数据排序
        for (int j = 0; j < arr.length; j++) {
            int digitOfElement = arr[j] / 10 % 10;//取个位
            //放入对应桶
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        // 按照桶的顺序，一维数组的下标一次取出数据，放入到原来的数组
        index = 0;
        for (int k = 0; k < bucketElementCounts.length; k++) {
            if (bucketElementCounts[k] != 0) {
                //有数据的
                //遍历这个数组
                for (int i = 0; i < bucketElementCounts[k]; i++) {
                    arr[index++] = bucket[k][i];
                }
            }
            //清空
            bucketElementCounts[k] = 0;
        }
        System.out.println(Arrays.toString(arr));
        //[3, 14, 214, 542, 748, 53]
        //第三次根据百位进行排序
        for (int j = 0; j < arr.length; j++) {
            int digitOfElement = arr[j] / 100 % 10;//取个位
            //放入对应桶
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        // 按照桶的顺序，一维数组的下标一次取出数据，放入到原来的数组
        index = 0;
        for (int k = 0; k < bucketElementCounts.length; k++) {
            if (bucketElementCounts[k] != 0) {
                //有数据的
                //遍历这个数组
                for (int i = 0; i < bucketElementCounts[k]; i++) {
                    arr[index++] = bucket[k][i];
                }
            }
        }
        System.out.println(Arrays.toString(arr));
        //[3, 14, 53, 214, 542, 748]
    }
```

```java
    //最终版
    public static void radixSortX(int[] arr) {
        //得到数组中最大位数
        //假设第一个是最大值
        int max = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        int maxLength = (max + "").length();

        int[][] bucket = new int[10][arr.length];
        //记录每个桶中存放了多少有效数据
        //bucketElementCounts[0 第一个桶的数据个数
        int[] bucketElementCounts = new int[10];

        for (int i = 0, n = 1; i < maxLength; i++, n *= 10) {
            for (int j = 0; j < arr.length; j++) {
                int digitOfElement = arr[j] / n % 10;//取个位
                //放入对应桶
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            int index = 0;
            for (int k = 0; k < bucketElementCounts.length; k++) {
                if (bucketElementCounts[k] != 0) {
                    //有数据的
                    //遍历这个数组
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        arr[index++] = bucket[k][l];
                    }
                }
                //清空
                bucketElementCounts[k] = 0;
            }
            System.out.println(Arrays.toString(arr));
        }
    }

```

> 基数排序不支持负数的数组，不过可以采用为所有元素加上同一个数变成正数数组    

## 堆排序  
等二叉树讲解完  



## 排序汇总  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/sort.png)



# 查找算法
Java中常用的查找算法有四种：
- 顺序(线性)查找
- 二分查找/折半查找
- 插值查找
- 斐波那契(黄金分割)查找

## 线性查找
线性查找就是从表中第一个数据开始逐个比对，直至找到目标值

```java
 public static int seqSearch(int[] arr, int value) {
        //逐一比对，发现有相同的值时就返回下标
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == value) {
                return i;
            }
        }
        return -1;
    }

//哨兵法 
    public static int seqSearch1(int[] arr, int val) {
        int i;
        arr[0] = val;
        i = arr.length - 1;
        while (arr[i] != val) {
            i--;
        }
        return i;
    }
```

## 二分查找
对`有序数组`的查找算法    
1. 首先确定数组中间值的下标    
2. 然后让目标值和中间值比较
3. 递归

```java

    /**
     * @param left    左边的索引
     * @param right   右边的索引
     * @param findVal 要查找的值
     * @return 目标值的索引
     */
    static int binarySearch(int[] arr, int left, int right, int findVal) {

        //找完了 没找到
        if (left > right) {
            return -1;
        }
        //找到中间值
        int mid = (left + right) / 2;
        int midVal = arr[mid];
        if (findVal > midVal) {
            //目标值在右边
            return binarySearch(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) {
            return binarySearch(arr, left, mid - 1, findVal);
        } else {
            return mid;
        }
    }
```

## 插值查找 
`插值查找算法`又称`插值搜索算法`，是在`二分查找算法`的基础上改进得到的一种查找算法。     
`插值查找算法`只适用于**有序序列**，它只能在升序序列或者降序序列中查找目标元素。作为“改进版”的二分查找算法

?> 当有序序列中的元素呈现`均匀分布`时，插值查找算法的查找效率要优于二分查找算法；  
反之，如果有序序列不满足均匀分布的特征，插值查找算法的查找效率不确定是否优于二分查找算法，看数组情况。

> 所谓均匀分布，是指序列中各个相邻元素的差值近似相等。例如，`{10, 20, 30, 40, 50} `就是一个均匀分布的升序序列，各个相邻元素的差值为10。再比如 `{100, 500, 2000, 5000}` 是一个升序序列，**但各相邻元素之间的差值相差巨大，不具备均匀分布的特征**    

!> 插值查找算法和二分查找基本相同，区别就是选择mid值的位置不同，插值算法需要根据下面的公式计算mid值    
`mid = left + (right - left) * (value - arr[left]) / (arr[right] - arr[left])`

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/插值查找.png)

```java
  private static int insertValueSearch(int[] arr, int left, int right, int findVal) {
        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {
            return -1;
        }
        //找到中间值
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
//        int mid = (left + right) / 2;
        int midVal = arr[mid];
        if (findVal > midVal) {
            //目标值在右边
            return insertValueSearch(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) {
            return insertValueSearch(arr, left, mid - 1, findVal);
        } else {
            return mid;
        }

    }
```


## 斐波那契/黄金分割查找 
斐波那契(黄金分割法)原理:  
斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于`黄金分割点`附近，即`mid = left + F(k-1) - 1`     

1. 由斐波那契数列` F[k]=F[k-1]+F[k-2]` 的性质，可以得到 `（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1` 。该式说明：只要顺序表的长度为`F[k]-1`，则可以将该表分成长度为`F[k-1]-1`和`F[k-2]-1`的两段，即如上图所示。从而中间位置为`mid=low+F(k-1)-1`         
2. 类似的，每一子段也可以用相同的方式分割   
3. 但顺序表长度n不一定刚好等于`F[k]-1`，**所以需要将原来的顺序表长度n增加至**`F[k]-1`。这里的k值只要能使得`F[k]-1`**恰好大于或等于n即可**，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到`F[k]-1`位置），都赋为n位置的值即可

```java
        while (high > f[k] - 1) {
            k++;
        }
```

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/斐波那契查找.png ':size=70%')


```java
 //生成斐波那契数列
    static int[] fib() {
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f;
    }

    /**
     * @param a：数组
     * @param key：我们需要查找的数
     * @return 返回对应的下标，如果没有就返回-1
     */
    public static int fibSearch(int[] a, int key) {
        int low = 0;             //左索引
        int high = a.length - 1;   //右索引
        int k = 0;               //表示斐波那契分割值的下标，即low+F(k-1)的k
        int mid = 0;             //存放mid的值
        int f[] = fib();         //获取斐波那契数列

        //获取到斐波那契分割数值的下标
        while (high > f[k] - 1) {
            k++;
        }
        //copyOf()的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值
        //因为f[k]值可能大于数组a的长度，因此我们需要使用Arrays类，构造新的数组，并指向a
        //不足的部分会使用0填充
        int[] temp = Arrays.copyOf(a, f[k]);

        //实际上需要使用a数组最后的数填充 temp
        //举例：temp = {1,8, 10, 89, 1000, 1234,0,0,0,0}  ==>{1,8, 10, 89, 1000, 1234,1234,1234,1234}
        for (int i = high + 1; i < temp.length; i++) {
            temp[i] = a[high];
        }

        // 使用while循环来处理，找到key
        while (low <= high) {
            mid = low + f[k - 1] - 1;

            if (key < temp[mid]) {
                //向数组的【左边】查找
                high = mid - 1;
                //说明
                //1、全部的元素=前面的元素+后面的元素
                //2、f[k] = f[k-1]+f[k-2]
                //因为前面有f[k-1]个元素，所以可以继续拆分  f[k-1] = f[k-2]+f[k-3]
                //即在f[k-1]的前面继续查找，k--
                //即下次循环的时候 mid = f[k-1-1]-1
                k--;
            } else if (key > temp[mid]) {
                //右移
                low = mid + 1;
                //说明：
                //1、全部的元素=前面的元素+后面的元素
                //2、f[k] = f[k-1]+f[k-2]
                //3、因为后面有f[k-2]，所以可以继续拆分 f[k-1] = f[k-3] +f[k-4]
                //4、即在f[k-2]的前面进行查找 k-=2
                //即下次循环的时候 mid = f[k-1-2]-1
                k -= 2;
            } else {
                //找到
                if (mid <= high) {
                    return mid;
                } else {
                    return high;
                }
            }
        }
        return -1;
    }

```

# 哈希表/散列表
散列表（Hashtable，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

# 树结构

## 存储结构分析
- 数组存储方式
  - 优点，通过下标访问，速度快，对于有序数组可以使用二分查找提高检索速度
  - 缺点，数组插入值会导致其他数据移动(先拷贝，再扩容)，效率低
- 链式存储
  - 插入、删除效率高 
  - 检索效率低，检索需要从头遍历
- 树存储方式
  - 能提高数据存储，读取效率，即能保证数据的检索速度，同时也能保证数据的插入，删除，修改速度

## 树
树是一种数据结构，它是由`n（n>=0）`个有限节点组成一个具有层次关系的集合，存储的是具有“一对多”关系的数据元素的集合

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/tree-demo.png ':size=70%')

- `根节点`树最顶端的节点，根节点没有父节点
- `子树`如果根节点不为空，则树 B，C 和 D 称为根节点的子树（树中各子树是互不相交的集合）
- `父节点`
- `叶子节点` 没有子节点的节点
- `边`两点的连接
- `路径`连续边的序列，节点E 的路径为`A-B-E`
- `高度/深度`树中层的数量，上图高度为4(4层)
- `层级` 根层级为 `Level0` 根的子节点为`Level1`
- `度`节点的度数等于子节点数。 在上图所示的树中，节点`B`的度数为`2`。叶子节点的度数总是`0`，而在完整的二叉树中，每个节点的度数等于`2`


## 二叉树
每个节点最多只能由两个子节点的一种树    
- 二叉树中不存在度大于 2 的结点
- 左子树和右子树是有顺序的，次序不能任意颠倒

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-tree-structure.jpeg)

- 深度为 k 的二叉树最多有 2^k – 1 个结点，最少有 k 个结点（k>=1）；
- `满二叉树`：如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树，也叫·
- `完全二叉树`：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-tree-special-case.jpeg ':size=70%')

**满二叉树一定是一颗棵完全二叉树，但完全二叉树不一定是满二叉树。**


### 二叉树的遍历 
遍历的含义就是把树的所有节点（Node）按照某种顺序访问一遍。包括`前序`，`中序`，`后序`，`广度优先（队列）`，`深度优先（栈）`5 种遍历方法

!> 之所以叫前序、中序、后序遍历，是因为根节点在前、中、后  

| 遍历方法 | 顺序                     | 示意图                                                       | 顺序     | 应用                                                         |
| -------- | ------------------------ | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| 前序     | **根 ➜ 左 ➜ 右**         | ![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-tree-preorder.png) | 12457836 | 想在节点上直接执行操作（或输出结果）使用先序                 |
| 中序     | **左 ➜ 根 ➜ 右**         | ![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-tree-inorder.png) | 42758136 | 在**二分搜索树**中，中序遍历的顺序符合从小到大（或从大到小）顺序的 要输出排序好的结果使用中序 |
| 后序     | **左 ➜ 右 ➜ 根**         | ![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-tree-postorder.jpeg) | 47852631 | 后续遍历的特点是在执行操作时，肯定**已经遍历过该节点的左右子节点** 适用于进行破坏性操作 比如删除所有节点，比如判断树中是否存在相同子树 |
| 广度优先 | **层序，横向访问**       | ![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-tree-leveltraverse.png) | 12345678 | 当**树的高度非常高**（非常瘦） 使用广度优先剑节省空间        |
| 深度优先 | **纵向，探底到叶子节点** | ![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-tree-dfs.png) | 12457836 | 当**每个节点的子节点非常多**（非常胖），使用深度优先遍历节省空间 （访问顺序和入栈顺序相关，相当于先序遍历） |


### 二叉树的查找
思路：采用前序，中序，后续三种遍历方式进行遍历查找  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-search-tree-penjee.gif)


### 二叉树节点删除
删除节点的规定： 
- 若删除的是叶子节点，则删除该节点
- 若删除的是非叶子节点，则删除该子树  

步骤：  
- 由于二叉树是单向的，所以需要判断当前接节点的子节点是否要删除，而不是判断当前节点
- 若当前节点的左子节点不为空，并且左子节点就是要删除的节点，直接`this.left = null`并返回，右子节点同理
- 若左右节点都不符合要求就进行递归


若修改规定，只删除指定的某个节点，那么流程如下
- 若是叶子节点直接移除即可
- 若是只有一个子节点的，那么直接删除该节点，替换为其子节点（例：删除元素 20）

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-serach-tree-del.png)
- 若删除的节点有两个子节点，那么取`左子树中的最大元素`或者`右子树中的最小元素`进行替换原位置
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/二叉树删除替换.gif)


## 顺序存储二叉树
从数据存储来看，数组存储方式和树存储方式可以互相转换，即数组可以转成树，树也可以转成数组

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-tree-2-array.png)

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/array-2-binary-tree.png)

顺序存储二叉树的特点：  
- 顺序存储二叉树通常只考虑完全二叉树
- 第n个元素的左子节点为`2n+1`
- 第n个元素的右子节点为`2n+2`
- 第n个元素的父节点为`(n-1)/2`
- n为数组中二叉树的index

```java
public class ArrBinaryTreeDemo {
	public static void main(String[] args) {
		int[] arr = { 1, 2, 3, 4, 5, 6, 7 };
		//创建一个 ArrBinaryTree
		ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
		arrBinaryTree.preOrder(); // 1,2,4,5,3,6,7
	}
}
//编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历
class ArrBinaryTree {
	private int[] arr;//存储数据结点的数组
	public ArrBinaryTree(int[] arr) {
		this.arr = arr;
	}
	//重载preOrder
	public void preOrder() {
		this.preOrder(0);
	}
	//编写一个方法，完成顺序存储二叉树的前序遍历
	/**
	 * @param index 数组的下标
	 */
	public void preOrder(int index) {
		//如果数组为空，或者 arr.length = 0
		if(arr == null || arr.length == 0) {
			System.out.println("数组为空，不能按照二叉树的前序遍历");
		}
		//输出当前这个元素
		System.out.println(arr[index]);
		//向左递归遍历
		if((index * 2 + 1) < arr.length) {
			preOrder(2 * index + 1 );
		}
		//向右递归遍历
		if((index * 2 + 2) < arr.length) {
			preOrder(2 * index + 2);
		}
	}
}

```

## 线索化二叉树  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/线索化二叉树.png)

上图中的 `#`是空的，会浪费一部分空间，如果我们希望将这些空的指针充分利用，让各个节点都可以指向自己的前驱结点和后继节点，那就需要使用到`线索二叉树`   


!> 现有一颗节点数为 `n` 的二叉树，采用二叉链表的形式存储。对于每个节点均有指向左右孩子的两个指针域，二节点为 `n` 的二叉树一共有` n-1 `个条有效分支路径。那么，则二叉链表中存在 `2n-(n-1)=n+1`个空指针域。那么这些空指针造成空间浪费

利用二叉链表中的`空指针域`，存放指向节点在**某种遍历次序**下的`前驱`和`后继`节点的指针,这种指针称为`线索`，这种树也就叫做线索二叉树   

根据线索性质(遍历次序)不同,可以分为前序、中序、后序线索二叉树    

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/中序遍历线索化二叉树.jpg)

当线索化二叉树后，Node节点的 属性 `left` 和 `right` ，有如下情况:    
- left 指向的是左子树，也可能是指向的前驱节点. 比如 A,B left 指向的左子树, 而E节点的 left 指向的就是前驱节点.
- right指向的是右子树，也可能是指向后继节点，比如A,B 节点right 指向的是右子树，而G,F节点的right 指向的是后继节点

代码实现`com.ric.hashtable.thread`

# 树结构的实际应用

## 堆 
堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，也是不稳定排序，最坏、最好、平均时间复杂度均为`O(nlogn)`   
堆是一个完全二叉树，且具有下列性质：
- `大顶堆` 每个节点的值都大于或等于其左右孩子节点的值(堆顶是最大值) 
- `小顶堆` 每个节点的值都小于或等于其左右孩子节点的值(堆顶是最小值)

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/大顶堆小顶堆.png)


## 堆排序 Heap Sort
堆排序是一种基于二叉堆数据结构的比较排序技术。类似于`选择排序`  

1. 将待排序序列构造成一个`大顶堆/小顶堆` 
2. 此时，整个序列的`最大值/最小值`就是堆顶的根节点
3. 将其与末尾元素进行交换，此时末尾就为`最大值/最小值`
4. 然后将剩余`n-1`个元素重新构造成一个`大顶堆/小顶堆`
5. 重复上述过程  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/heapSort.gif)

堆排序的for循环实现：   

```java
public class HeapSort {
    public static void main(String[] args) {
        int[] arr = {4, 6, 8, 5, 9};
        heapSort(arr);
    }

    public static void heapSort(int[] arr) {
        System.out.println("堆排序！");
        //先变成大顶堆
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }
        //[9, 6, 8, 5, 4]
        System.out.println(Arrays.toString(arr));
        int temp = 0;
        for (int j = arr.length - 1; j > 0; j--) {
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr, 0, j);
        }
        //[4, 5, 6, 8, 9]
        System.out.println(Arrays.toString(arr));
    }

    /**
     * @param arr    待调整数组
     * @param i      非叶子节点的在数组中的索引
     * @param length 表示对多少个元素进行调整，length 在逐渐减少
     */
    //将一个数组（二叉树） 调整为大顶堆
    public static void adjustHeap(int[] arr, int i, int length) {
        int temp = arr[i];
        //i*2+1 是i节点的左子节点
        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            //先找到i 子节点中较大的值
            //若i的左子节点小于右子节点
            if (k + 1 < length && arr[k] < arr[k + 1]) {
                k++;//k指向右子节点
            }

            //若子节点大于父节点
            if (arr[k] > temp) {
                arr[i] = arr[k];//把较大的值赋予当前节点
                i = k;//继续对其孩子节点循环 其孙子节点
            } else {
                break;
            }
        }
        //当for循环结束后，已经将已i为父节点的树的最大值放在了 i 的位置
        arr[i] = temp;
    }
}
```

递归实现

```java
 public static void sort(int arr[]) {
        int N = arr.length;

        // 创建大顶堆
        for (int i = N / 2 - 1; i >= 0; i--)
            heapify(arr, N, i);

        // 将堆顶放在数组最后
        for (int i = N - 1; i > 0; i--) {
            // Move current root to end
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            //用剩下的数组元素组成大顶堆
            heapify(arr, i, 0);
        }
    }

    static void heapify(int arr[], int N, int i) {
        int largest = i; // Initialize largest as root
        int l = 2 * i + 1; // left = 2*i + 1
        int r = 2 * i + 2; // right = 2*i + 2

        // N的左子节点大于 N ，将最大值替换为左子节点
        if (l < N && arr[l] > arr[largest])
            largest = l;

        // N的右子节点大于 N ，将最大值替换为右子节点
        if (r < N && arr[r] > arr[largest])
            largest = r;

        // 最大值不是根节点就进行替换 并递归
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            heapify(arr, N, largest);
        }
    }
```

## 赫夫曼树 Huffman Tree

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼树1.png)

赫夫曼树的核心概念：  

`路径`和`路径长度`，从树的一个节点到另一个节点之间的分支构成两个节点之间的`路径`，`路径`上的分支数目称作`路径长度`    
> 二叉树a中 根节点到节点D的路径长度就为4，二叉树b中，根节点到节点D的路径长度为2  

**树**的`路径长度`就是从树根到每一个节点的路径长度之和    
> 二叉树a的路径长度就是`1+1+2+2+3+3+4+4=20`   
> 二叉树b的路径长度就是`1+2+3+3+2+1+2+2=16`

`节点的带权路径长度` 在路径长度的基础上，若考虑节点权重，就是带权路径长度，计算方法为：该节点到树根之间的路径长度与节点权的乘积，即为节点的带权路径长度     
`树的带权路径长度(WPL)` 所有**叶子节点**的带权路径长度之和 

> 二叉树a的`WPL=5*1+15*2+40*3+30*4+10*4=315`   
> 5是A节点的权值，1是A节点到树根的路径长度   
> 二叉树b的`WPL=3*5+3*15+2*40+2*30+2*10=220`,**此时我们说二叉树b是优于二叉树a的**

所以当给定`n`个权值作为`n个叶子节点`构造一颗`二叉树`，若该树的`带权路径长度`达到最小，称这样的二叉树为`最优二叉树`，也就是`赫夫曼树`   

?> 赫夫曼树是带权路径长度最短的树，权值较大的节点离根较近  


### 生成赫夫曼树  
1. 若有数组`13, 7, 8, 3, 29, 6, 1`  
2. 先对其进行排序得到有序数组`1, 3, 6, 7, 8, 13, 29` 
3. 将每个元素看作一颗二叉树，取出根节点最小的两个二叉树，组成新的二叉树
4. 即取出元素`1,3`组成一颗二叉树如下图

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼树构造1.png)

5. 再取出元素`6` 与上面的二叉树构成新的二叉树 

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼树构造2.png)

6. 再将元素`7,8` 构成一颗二叉树 

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼树构造3.png)

7. 将元素`13`和步骤五构成一颗新二叉树，并和步骤6组合得到  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼树构造4.png)

8. 最终剩余元素 `27,69`进行组合

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼树构造4.png)


```java
/**
 * 赫夫曼树
 */
public class HuffmanTree {
    public static void main(String[] args) {
        int[] arr = {13, 7, 8, 3, 29, 6, 1};
        Node huffmanTree = createHuffmanTree(arr);

        huffmanTree.preList();
    }

    public static Node createHuffmanTree(int[] arr) {
        //遍历arr 将其转成Node List
        List<Node> nodes = new ArrayList<>();
        for (int i : arr) {
            nodes.add(new Node(i));
        }
        while (nodes.size() > 1) {
            Collections.sort(nodes);
//            System.out.println(nodes);
            //取出前两个元素
            Node left = nodes.get(0);
            Node right = nodes.get(1);

            //构建第一个二叉树
            Node parent = new Node(left.value + right.value);
            parent.left = left;
            parent.right = right;

            //从list中删除处理过的元素
            nodes.remove(left);
            nodes.remove(right);

            //parent加入
            nodes.add(parent);
//            System.out.println(nodes);
        }
        return nodes.get(0);
    }

}

class Node implements Comparable<Node> {
    int value;//权
    Node left;//左子节点
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        //从小到大排序
        return this.value - o.value;
    }

    public void preList() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preList();
        }
        if (this.right != null) {
            this.right.preList();
        }
    }
}
```

## 赫夫曼编码  
通过一个案例来说明`赫夫曼编码`,大话数据结构上的案例，视频中的案例类似   

1. 当我们有第一段文字内容为 `BADCADFEED`需要传输，传统采用二进制表示并传输  
2. 发现字母出现的频次不同，以他们出现的频率作为权重，构建赫夫曼树  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼编码构造1.png)

3. 在此基础上，将节点左分支权值改为0，右分支权值改为1，得到  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼编码构造2.png)

4. 此时我们用路径进行编码 那么  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼编码构造3.png)

5. 编码对比

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/赫夫曼编码构造4.png)

6. 可以看到数据被压缩了，接收到数据后，同样使用该赫夫曼树进行解码  

!> 赫夫曼树根据排序方式不同，生成的树可能不太一样，对应的赫夫曼编码也不同，但是生成赫夫曼树的`带权路径长度WPL`是相同的  

> `《大话数据结构》` 一般的，设需要编码的字符集为`d1,d2,...,dn`各个字符在电文中出现的次数或者频率集合为`w1,w2,...,wn`，以`d1,d2,...,dn`作为叶子节点，以`w1,w2,...,wn` 作为相应叶子节点的权值来构造一棵`赫夫曼树`，规定赫夫曼树的左分支代表`0`，右分支代表`1`，则从根节点到叶子节点所经过的路径分支组成的`0`和`1`的序列便为该节点对应字符的编码，这就是**赫夫曼编码**

?> 关于赫夫曼编码视频集数为 `P112-P126` 观看到实现赫夫曼编码P120,后续略,代码包名`com.ric.huffman.code`


## 二叉排序(查找)树 (BST) Binary Sort(Search) Tree  

对于二叉排序树任何一个非叶子节点，要求**左子节点的值比当前节点的值小**，**右子节点的值比当前节点的值大**，若有相同的值，可以讲该系欸但那放在左子节点或右子节点  

- 若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值
- 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值
- 左、右子树也分别为二叉排序树
- 没有键值相等的节点

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-search-tree.jpeg ':size=60%')

二叉查找树是一个递归的数据结构。对二叉查找树进行`中序遍历`，即可得到有序的数列  

### 节点删除
节点删除主要分三种情况：  
- `删除叶子节点`：直接移除该节点，并且将父节点原本指向该位置改为`null`(如果是根节点，那就不用修改父节点指向位置)
- `删除只有一颗子树的节点`:直接删除该节点，并且将父节点原本指向的位置改为该儿子 (如果是根节点，那么该儿子成为新的根节点)  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-serach-tree-del.png)

- `删除有两颗子树的节点`:取`左子树中最大元素`或者`右子树中最小元素`进行替换，然后将最大元素最小元素原位置置空

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/binary-serach-tree-del2.gif)

代码详见`com.ric.sorttree.BinarySortTreeDemo`


### 时间复杂度
它和二分查找一样，插入和查找的时间复杂度均为`O(log2n)`，但是在最坏的情况下仍然会有 `O(n)` 的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。



## 平衡二叉树
基于上一节，当对数列`1,2,3,4,5,6`进行二叉排序时，我们发现创建的二叉树是一条斜线  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/偏向的二叉树.png)

?> 此时这个二叉树的效率就很低了，查询速度明显降低，甚至慢于单链表   

需要更高效的树：  
**平衡二叉树**： 也叫平衡二叉搜索树(Self-Blancing Binary Search Tree)、AVL树  

左子树上的所有节点的值都比根节点的值小，而右子树上的所有节点的值都比根节点的值大，且左子树与右子树的`高度差最大为1`。因此，平衡二叉树满足所有二叉排序（搜索）树的性质：

- 可以是空树
- 假如不是空树，**任何一个结点的左子树与右子树都是平衡二叉树**，并且高度之差的绝对值不超过 1

**平衡因子**：将二叉树上节点的左子树深度减去右子树深度的值称为平衡因子BF(Balance Factor),那么平衡二叉树上所有节点的平衡因子只能是 `1、0、-1`分别对应着左子树比较高，左右子树等高，右子树比较高


### 单旋转 左旋转/右旋转

我们以左旋为例

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/手绘左旋转.jpg ':size=70%')

1. 创建一个新节点(以4这个值创建)值等于当前`根节点`的值，把新节点的`左子树`设置成当前节点的`左子树`
2. 把新结点的`右子树`设置为当前节点`右子树`的`左子树`
3. 把当前节点的值换为`右子节点`的值
4. 把当前节点的`右子树`设置成`右子树`的`右子树`
5. 把当前节点的`左子树`设置为新节点  

### 双旋转  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/双旋转案例.jpg ':size=70%')

如图，开始的二叉树是不能直接通过`右旋转`进行平衡的，因为**左子树的右子树高度大于它的左子树**,此时需要先对这个`节点`的`左子树`进行左旋，再对整个树进行`右旋`   

同理，若右子树的左子树高度大于它的右子树，需要先对右子树`右旋`再整体`左旋`

?> 常见的非平衡的二叉树 

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/失去平衡的四种二叉树.png)

## 多路查找树
二叉树只能有两个节点，一颗二叉树的节点数为 `2^n -1` n 为二叉树的高度，若需要很多节点会导致二叉树非常高，构建该二叉树和操作二叉树都会影响效率    

针对上述问题，我们引入多叉树，允许每个节点可以有更多的数据项和更多的子节点  
 
### 2-3树
2-3树是由二节点和三节点构成的树   
有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点  
有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/2-3树.jpg ':size=70%')


### B树 B+树 B*树
`B-tree`树即B树，B即`Balanced`B树通过重新组织节点，降低树的高度，并且减少IO读写次数来提升效率  

[B树B+树相关 查看Mysql ](/Java/MySQL?id=b树)

B*树是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针  


# 图
线性表局限于一个直接前驱和一个直接后继的关系   
树是一个直接前驱和多个子节点关系
而图是一个表示多对多的关系   

## 概念  

- `顶点`图中的数据元素，称之为顶点  
- `无向边/有向边` 顶点到顶点之间是否有方向，有向边又叫弧，起始点是弧头，终点是弧尾
- `有向图`如果任意两个顶点之间的边都是有向边，则该图为有向图
  - `有向完全图` 有向图中，任意两个顶点之间都存在方向相反的两条弧，则为有向完全图
- `无向图`有一条边是无向边
  - `无向完全图` 无向图中，任意两个顶点之间都存在边，则为无向完全图 

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/有向图-无向图.png)  
- 有很少条边或弧的图称为`稀疏图`，反之为`稠密图`，相对概念
- `带权图`边带权值的图，也叫`网`

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/带权图.png)

## 图的存储结构  

### 邻接矩阵
邻接矩阵使用两个数组来表示图，一个一维数组存储图中的顶点信息，一个二维数组存储顶点之间的关系

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/邻接矩阵.png)


### 邻接表
邻接矩阵需要对每个顶点都分配n个边的空间，对于稀疏图来说，很多空间都浪费了，因为很多顶点没有边 

邻接表的实现就只关心存在的边，由数组+链表组成  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/邻接表.png)

## 图的代码实现
使用邻接矩阵实现一个无向图  

```java

/**
 * 图结构的代码实现
 */
public class Graph {
    private ArrayList<String> vertexList;
    private int[][] edges;
    private int numOfEdges;

    public static void main(String[] args) {
        int n = 5;//节点个数
        String[] VertexValue = {"A","B","C","D","E"};
        Graph graph = new Graph(n);
        for (String ver : VertexValue) {
            graph.insertVertex(ver);
        }
        // AB AC BC BD BE
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);

        graph.showGraph();

    }

    public Graph(int n) {
        edges = new int[n][n];
        vertexList = new ArrayList<>(n);
        numOfEdges = 0;
    }

    //返回节点个数
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //边的个数
    public int getNumOfEdges() {
        return numOfEdges;
    }

    String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    //添加节点
    void insertVertex(String vertex) {
        vertexList.add(vertex);

    }

    //显示图对应的矩阵
    void showGraph() {
        for (int[] link : edges) {
            System.out.println(Arrays.toString(link));
        }
    }

    //添加边
    void insertEdge(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

}
```

## 图的遍历  
图的遍历有两种策略  
- 深度优先遍历(DFS)
- 广度优先遍历

?> 上述是图的深度和广度优先遍历方法，和广义的深度优先遍历还有区别  

### 深度优先遍历DFS

**深度优先遍历**，从初始访问节点出发，初始访问节点可能有多个邻接节点，深度优先遍历的策略就是首先访问第一个邻接节点，然后再以这个被访问的邻接节点作为初始节点，访问它的第一个邻接节点。

每次再访问完当前节点后，首先访问当前节点的`第一个邻接节点`，深度优先搜索是一个递归过程

- 访问初始节点V，并标记为已访问
- 查找V的第一个邻接节点W
- 若W存在，执行下一步，若不存在回到第一步，从V的下一个邻接节点开始
- 若W未被访问，对W进行深度优先遍历递归（把W作为初始节点执行前三步）
- 查找节点V的W邻接节点的下一个邻接节点，继续判断其是否存在（第三步）

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/图的深度优先案例.png ':size=70%')

> 以A为初始节点，A的邻接节点为B，B的邻接节点为C,C没有邻接节点，则返回寻找B的第二个邻接节点，即D，D也没有邻接节点，寻找B的第三个邻接节点E，顺序为 ABCDE


### 广度优先遍历BFS
广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点    
广度优先类似于树的层序遍历   


![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/图的广度优先遍历.png)



# 常用算法  

## 二分查找算法（非递归）

```java
 /**
     * @param arr    待查找数组 默认升序数组
     * @param target 目标值
     * @return 下标，-1则没找到
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] == target) {
                return mid;

            } else if (arr[mid] > target){
                //在左半部分查找
                right = mid-1;
            }else {
                left = mid+1;
            }
        }
        return -1;
    }
```

## 分治算法  
分而治之，即把一个复杂的问题分解成两个或者更多相同或相似的问题，再把子问题分成更小的子问题，直至最后可以简单的直接求解，原问题的解即子问题解的合并  

?> 常见如：二分查找，大整数乘法，归并排序，快速排序，汉诺塔...

基本步骤：   
- 分解 分解问题
- 解决 解决子问题
- 合并 合并子问题的解

###  汉诺塔
分治算法最佳实践-汉诺塔

> ​ 给定三根柱子，记为A,B,C，其中A柱子上有N个盘子，从上到下编号为0到N-1，且上面的盘子一定比下面的盘子小。问：将A柱上的盘子经由B柱移动到C柱(顺序不变)最少需要多少次?

此时，我们考虑，若只有一个盘，那么直接将其从A移动到C；若有`N>=2`情况，我们总是可以看做两个盘，1.最下面的盘；2.上面的所有盘看作一个盘     

- 先把最上面的盘由A移动到B，不论多少盘都算
- 把最下面的盘由A移动到C
- 把B的所有盘移动到C，此时A作为中间盘

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/Tower_of_Hanoi_4.gif)   


```java
/**
 * 汉诺塔
 */
public class Hanoitower {
    public static void main(String[] args) {
        hanoTower(3, 'A', 'B', 'C');
    }

    /**
     * @param num 盘数量
     * @param a   起始点
     * @param b   中间
     * @param c   目标
     */
    //汉诺塔移动的方法
    //使用分治算法
    public static void hanoTower(int num, char a, char b, char c) {
        //若只有一个盘
        if (num == 1) {
            System.out.println("第1个盘从 " + a + "->" + c);
        } else {
            //n>=2 我们总是可以看作 两个盘，最下面一个盘，剩余上面的一个盘
            //1.先把最上面的 A -> B 一直递归
            hanoTower(num - 1, a, c, b);

            //2.把最下面的盘 A -> C
            System.out.println("第" + num + "个盘从 " + a + "->" + c);

            //把左右盘由B -> C
            hanoTower(num - 1, b, a, c);
        }
    }

}
```

## 动态规划算法❌
**这个算法看了两遍视频完全没理解**

背包问题： 有了个容量为4磅的背包，现有如下物品 ：

物品 | 重量 |价格
----|-----|-----
 吉他 | 1 | 1500
 音响 | 4 | 3000
 电脑 | 3 | 2000

1. 要求实现，装入背包的总价值最大，并且不能超重
2. 装入的物品不能重复    

> 背包问题又分为01背包(物品不能重复)和完全背包(物品可以重复)


### 介绍
- 动态规划算法的核心思想：将大问题划分为小问题进行解决，从而**一步步**获得最优解的处理算法
- 动态规划和分治类似，基本思想也是将求解的问题分解成若干个问题，求解子问题
- 与分治不同的是，动态规划求解的问题，分解的子问题是一步步执行(下一个步骤是以上一个步骤的解为基础的)
- 动态规划可以通过**填表的方式**来逐步推进，得到最优解

### 解决背包问题

每次遍历到第i个物品，根据w[i] 和v[i] 来确定是否需要将该物品放入背包中。    
即对于给定的n个物品，设v[i] 、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值，则有如下结果  

- `v[i][0]=v[0][j]=0;` 表示 填入表 第一行和第一列是0
- 当`w[i]> j` 时：`v[i][j]=v[i-1][j]` 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略
- 当`j>=w[i]`时： `v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}` 当准备加入的新增的商品的容量小于等于当前背包的容量 
  - `v[i-1][j]`： 就是上一个单元格的装入的最大值
  - `v[i]` : 表示当前商品的价值 
  - `v[i-1][j-w[i]]` ： 装入i-1商品，到剩余空间`j-w[i]`的最大值

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/动态规划案例.png)


## KMP算法

若有两个个字符串`1121211233345` 和 `123` 现在要判断 字符串1中是否包含字符串2，若存在就返回第一次出现的位置，若不存在就返回-1  

传统方法：暴力匹配，对两个字符串中的字符依次进行匹配  

```java
//str1 中检索 str2
static int violenceMathc(String str1, String str2) {
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();
        int s1l = s1.length;
        int s2l = s2.length;

        int i = 0;//s1索引
        int j = 0;//s2索引
        //保证检索时不越界
        while (i < s1l && j < s2l) {
            System.out.println(i);
            if (s1[i] == s2[j]) {
                i++;
                j++;
            } else {
                //匹配失败
                i = i - (j - 1);
                j = 0;
            }

        }
        //匹配成功
        if (j == s2l) {
            return i - j;
        }
        return -1;
    }
```

### 介绍
KMP是一个解决模式串在文本串中是否出现过，并获取最早出现位置的经典算法   
利用之前判断过信息，通过一个next数组，保存模式串中**前后最长公共子序列的长度**，每次回溯时，通过next数组找到前面匹配过的位置，省去大量的计算时间   

### 部分匹配表
部分匹配表也就是next数组，根据字符串生成一个数组  

1. 说明字符串的前缀和后缀，"前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/前缀后缀说明.png)

2. `部分匹配值`就是`前缀`和`后缀`的最长的共有元素的长度。以`ABCDABD`为例 

- `A` 的前缀和后缀都为空集，共有元素的长度为 0；
- `AB` 的前缀为`[A]`，后缀为`[B]`，共有元素的长度为 0；
- `ABC` 的前缀为`[A, AB]`，后缀为`[BC, C]`，共有元素的长度 0；
- `ABCD` 的前缀为`[A, AB, ABC]`，后缀为`[BCD, CD, D]`，共有元素的长度为 0；
- `ABCDA` 的前缀为`[A, AB, ABC, ABCD]`，后缀为`[BCDA, CDA, DA, A]`，共有元素为`A`，长度为 1；
- `ABCDAB` 的前缀为`[A, AB, ABC, ABCD, ABCDA]`，后缀为`[BCDAB, CDAB, DAB, AB, B]`，共有元素为`AB`，长度为 2；
- `ABCDABD` 的前缀为`[A, AB, ABC, ABCD, ABCDA, ABCDAB]`，后缀为`[BCDABD, CDABD, DABD, ABD, BD, D]`，共有元素的长度为 0。

3. 所以可以生成一个部分匹配表  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/部分匹配表.png)  

### 算法过程  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程1.png)

- 首先，字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程2.png) 

- 直到字符串有一个字符，与搜索词的第一个字符相同为止,接着比较字符串和搜索词的下一个字符   
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程3.png)   
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程4.png)   

- 直到字符串有一个字符，与搜索词对应的字符不相同为止。  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程5.png)
 
- ❌此时暴力方法就是继续后移一位进行匹配  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程6.png)

- 当空格与D不匹配时，你其实知道前面六个字符是`ABCDAB`。KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率
- 根据子串的`部分匹配表`和公式来计算向后移动的位数    
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/部分匹配表.png)    
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程5.png)

?> 已知空格与D不匹配时，前面六个字符 `ABCDAB` 是匹配的。查表可知，**最后一个匹配字符B**对应的`部分匹配值`为2，因此按照下面的公式算出向后移动的位数  
`移动位数 = 已匹配的字符数 - 对应的部分匹配值` 即`4=6-2` 向后移动4位

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程7.png)  

?> 因为空格与C不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（"AB"），**最后一个匹配字符B**对应的"部分匹配值"为0。所以，`移动位数 = 2 - 0`，结果为 2，于是将搜索词向后移2位  

- 继续后移  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程8.png)   
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程10.png)  

?> 逐位比较，直到发现C与D不匹配。于是，`移动位数 = 6 - 2`，继续将搜索词向后移动4位  

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/匹配过程11.png)  

?> 此时完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），`移动位数 = 7 - 0`，再将搜索词向后移动7位

```java

/**
 * KMP算法
 */
public class KMPAlgorithm {
    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";
        int[] next = kmpNext(str2);
        int i = kmpSearch(str1, str2, next);
        System.out.println(Arrays.toString(next));//[0, 0, 0, 0, 1, 2, 0]
        System.out.println(i);//15

    }


    
    /**
     * @param str1 源字符串 i
     * @param str2 子串 j
     * @param next 部分匹配表（子串的）
     * @return -1没有匹配到，否则返回第一个匹配的位置
     */
    static int kmpSearch(String str1, String str2, int[] next) {

        for (int i = 0, j = 0; i < str1.length(); i++) {

            //算法核心 公式
            while (j > 0 && str1.charAt(i) != str2.charAt(j)) {
                j = next[j - 1];
            }

            if (str1.charAt(i) == str2.charAt(j)) {
                j++;
            }
            //找到了 j=3时， i=2
            if (j == str2.length()) {
                return i - j + 1;
            }

        }
        return -1;
    }


    //获取到子串 的部分匹配值(表)
    static int[] kmpNext(String dest) {
        //创建数组保存部分匹配值
        int[] next = new int[dest.length()];
        //若字符串长度为1 部分匹配值就是0
        next[0] = 0;
        //i 是后缀 j是前缀
        for (int i = 1, j = 0; i < dest.length(); i++) {
            //当不同时，需要从next[j-1] 获取新的 j  直至有dest.charAt(i) == dest.charAt(j) 才能退出
            //KMP核心 一直找，知道有相同的或者找完
            while (j > 0 && dest.charAt(i) != dest.charAt(j)) {
                j = next[j - 1];
            }
            //部分匹配值+1
            if (dest.charAt(i) == dest.charAt(j)) {
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}
```

## 贪心算法  
贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法  
贪婪算法所得到的结果**不一定是最优的结果**(有时候会是最优解)，但是都是相对近似(接近)最优解的结果

### 贪心算法应用-集合覆盖
假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择**最少的广播台，让所有的地区都可以接收到信号**

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/贪心算法广播台.png)

使用穷举法，n个广播台总共有 `2^n -1`个组合  

使用贪心算法：   
- 遍历所有广播电台，找到覆盖地区最多的电台，
- 将这个电台加入到集合中，想办法把该电台覆盖的地区在下一次比较时去掉  
- 重复第一步直至覆盖全部   

实际操作流程：
- 创建集合包括所有要覆盖的地区`areaList`
- 遍历广播台，选出覆盖最多的第一个广播台，同时移除`areaList`中该广播台覆盖的区域，并将该广播台加入集合`radioList`
- 重复第二步，直至`areaList`为空 

```java
/**
 * 贪心算法
 */
public class GreedyAlgorithm {
    public static void main(String[] args) {
        HashMap<String, HashSet<String>> boradcasts = new HashMap<>();

        HashSet<String> hashSet1 = new HashSet<>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");
        HashSet<String> hashSet2 = new HashSet<>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");
        HashSet<String> hashSet3 = new HashSet<>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");
        HashSet<String> hashSet4 = new HashSet<>();
        hashSet4.add("上海");
        hashSet4.add("天津");
        HashSet<String> hashSet5 = new HashSet<>();
        hashSet5.add("杭州");
        hashSet5.add("大连");

        boradcasts.put("K1", hashSet1);
        boradcasts.put("K2", hashSet2);
        boradcasts.put("K3", hashSet3);
        boradcasts.put("K4", hashSet4);
        boradcasts.put("K5", hashSet5);

        HashSet<String> allAreas = new HashSet<>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("成都");
        allAreas.add("杭州");
        allAreas.add("大连");

        //创建list 存放选择的电台集合 最终的结果
        List<String> list = new ArrayList<>();

        //定义一个临时集合 保存在遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
        // 通过这个集合的size 来判断交集大小，进行贪心选择，选size最大的
        HashSet<String> tempSet = new HashSet<>();
        //定义一个maxKey 保存在一次遍历过程中，能覆盖最大的区域 对应电台的key
        String maxKey = null;

        //只要没有覆盖所有区域就一直循环
        while (allAreas.size() != 0) {
            maxKey = null;
            //遍历所有电台
            for (String key : boradcasts.keySet()) {
                tempSet.clear();
                //当前电台的key
                HashSet<String> hashSet = boradcasts.get(key);
                tempSet.addAll(hashSet);
                //当前电台和未覆盖区域的交集
                tempSet.retainAll(allAreas);
                //遍历所有电台挑交集最多的，
                if (tempSet.size() > 0 && (maxKey == null || tempSet.size() > boradcasts.get(maxKey).size())) {
                    maxKey = key;
                }
            }
            if (maxKey != null) {
                list.add(maxKey);
                //清除本次覆盖的地区
                allAreas.removeAll(boradcasts.get(maxKey));
            }
        }
    }
}
```

## 最小生成树MST

最小生成树(Minimum Cost Spanning Tree)，简称MST   
给定一个带权的无向连通图，如果选取一颗生成树，使书上所有边上权的总和为最小，就叫最小生成树

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/最小生成树.png)  

求最小生成树的算法主要是 `普利姆(Prim)`算法 和 `克鲁斯卡尔(kruskal)`算法

### 普利姆(Prim)算法  
![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/普利姆算法案例.png)

1. 从顶点A开始处理，AB权为5，AC权为7，AG权为2，所以选择AG
2. 和A,G相连并没有处理过的顶点开始，AC 7,AB 5,GB 3，GE 4，GF 6，所以选AGB
3. 和AGB相连并没有处理过的顶点， AC 7，GE 4，GF 6，BD 9,所以选 AGBE ....

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/普利姆算法结果.jpg) 


### 克鲁斯卡尔(kruskal)算法
是用来求加权连通图的最小生成树的算法  
按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路   
首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/克鲁斯卡尔.png)

![](https://hexoric-1310528773.cos.ap-beijing.myqcloud.com/hexo/克鲁斯卡尔步骤.jpg)

1. 选择权最小的边EF
2. 继续选择权最小的边 CD
3. 继续 DE
4. 选择不能构成回路的权最小的边 FB,CE会构成回路  
5. 总权值 2+3+4+7+8+12

## 最短路径 

### 迪杰斯特拉算法
迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止

### 佛洛依德算法  
弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法  
弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径   




## 限流算法

### 漏桶算法

### 令牌桶算法




















































































































# 参考资料
> - [尚硅谷视频](https://www.bilibili.com/video/BV1E4411H73v)
> - [javakeeper](https://javakeeper.starfish.ink/data-structure-algorithms/)
> - [经典排序算法](https://github.com/hustcc/JS-Sorting-Algorithm)
> - [《大话数据结构》](https://book.douban.com/subject/35229404/)
> - [KMP算法参考](https://www.cnblogs.com/zzuuoo666/p/9028287.html)
> - [ruanyifeng](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)
> - [算法教程](http://c.biancheng.net/algorithm/what-is-algorithm.html)